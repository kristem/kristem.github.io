<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Java基础之String源码 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="String表示字符串，Java中所有字符串的字面值都是String类的实例，例如“ABC”。字符串是常量，在定义之后不能被改变，字符串缓冲区支持可变的字符串。因为 String 对象是不可变的，所以可以共享它们。例如： 1String str = &amp;quot;abc&amp;quot;; 相当于 12char data[] = &amp;#123;&amp;apos;a&amp;apos;, &amp;apos;b&amp;apos;, &amp;a">
<meta name="keywords" content="Java基础">
<meta property="og:type" content="article">
<meta property="og:title" content="Java基础之String源码">
<meta property="og:url" content="http://yoursite.com/2019/02/16/Java基础之String源码/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="String表示字符串，Java中所有字符串的字面值都是String类的实例，例如“ABC”。字符串是常量，在定义之后不能被改变，字符串缓冲区支持可变的字符串。因为 String 对象是不可变的，所以可以共享它们。例如： 1String str = &amp;quot;abc&amp;quot;; 相当于 12char data[] = &amp;#123;&amp;apos;a&amp;apos;, &amp;apos;b&amp;apos;, &amp;a">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-09-05T00:58:23.780Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java基础之String源码">
<meta name="twitter:description" content="String表示字符串，Java中所有字符串的字面值都是String类的实例，例如“ABC”。字符串是常量，在定义之后不能被改变，字符串缓冲区支持可变的字符串。因为 String 对象是不可变的，所以可以共享它们。例如： 1String str = &amp;quot;abc&amp;quot;; 相当于 12char data[] = &amp;#123;&amp;apos;a&amp;apos;, &amp;apos;b&amp;apos;, &amp;a">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Java基础之String源码" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/16/Java基础之String源码/" class="article-date">
  <time datetime="2019-02-16T00:55:30.000Z" itemprop="datePublished">2019-02-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Java基础之String源码
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>String表示字符串，Java中所有字符串的字面值都是String类的实例，例如“ABC”。字符串是常量，在定义之后不能被改变，字符串缓冲区支持可变的字符串。因为 String 对象是不可变的，所以可以共享它们。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;abc&quot;;</span><br></pre></td></tr></table></figure>
<p>相当于</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char data[] = &#123;&apos;a&apos;, &apos;b&apos;, &apos;c&apos;&#125;;</span><br><span class="line">String str = new String(data);</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>这里还有一些其他使用字符串的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(&quot;abc&quot;);</span><br><span class="line">String cde = &quot;cde&quot;;</span><br><span class="line">System.out.println(&quot;abc&quot; + cde);</span><br><span class="line">String c = &quot;abc&quot;.substring(2,3);</span><br><span class="line">String d = cde.substring(1, 2);</span><br></pre></td></tr></table></figure>
<p>String类提供了检查字符序列中单个字符的方法，比如有比较字符串，搜索字符串，提取子字符串，创建一个字符串的副本、字符串的大小写转换等。实例映射是基于<code>Character</code>类中指定的Unicode标准的。 <strong>Java语言提供了对字符串连接运算符的特别支持（+）</strong>，该符号也可用于将其他类型转换成字符串。字符串的连接实际上是通过<code>StringBuffer</code>或者<code>StringBuilder</code>的<code>append()</code>方法来实现的，字符串的转换通过<code>toString</code>方法实现，该方法由 Object 类定义，并可被 Java 中的所有类继承。 除非另有说明，传递一个空参数在这类构造函数或方法会导致<code>NullPointerException</code>异常被抛出。<strong>String表示一个字符串通过UTF-16(unicode)格式</strong>，补充字符通过代理对（参见Character类的 Unicode Character Representations 获取更多的信息）表示。索引值参考字符编码单元，所以补充字符在String中占两个位置。</p>
<hr>
<blockquote>
<p><a href="http://www.hollischuang.com/archives/99#%E5%AE%9A%E4%B9%89" target="_blank" rel="noopener">定义</a> <a href="http://www.hollischuang.com/archives/99#%E5%B1%9E%E6%80%A7" target="_blank" rel="noopener">属性</a> <a href="http://www.hollischuang.com/archives/99#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95" target="_blank" rel="noopener">构造方法</a></p>
<blockquote>
<p><a href="http://www.hollischuang.com/archives/99#%E4%BD%BF%E7%94%A8%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9E%84%E9%80%A0%E4%B8%80%E4%B8%AAString" target="_blank" rel="noopener">使用字符数组、字符串构造一个String</a></p>
<p><a href="http://www.hollischuang.com/archives/99#%E4%BD%BF%E7%94%A8%E5%AD%97%E8%8A%82%E6%95%B0%E7%BB%84%E6%9E%84%E9%80%A0%E4%B8%80%E4%B8%AAString" target="_blank" rel="noopener">使用字节数组构造一个String</a></p>
<p><a href="http://www.hollischuang.com/archives/99#%E4%BD%BF%E7%94%A8StringBuffer%E5%92%8CStringBuider%E6%9E%84%E9%80%A0%E4%B8%80%E4%B8%AAString" target="_blank" rel="noopener">使用StringBuffer和StringBuider构造一个String</a></p>
<p><a href="http://www.hollischuang.com/archives/99#%E4%B8%80%E4%B8%AA%E7%89%B9%E6%AE%8A%E7%9A%84%E4%BF%9D%E6%8A%A4%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95" target="_blank" rel="noopener">一个特殊的保护类型的构造方法</a></p>
</blockquote>
<p><a href="http://www.hollischuang.com/archives/99#%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95" target="_blank" rel="noopener">其他方法</a></p>
<blockquote>
<p><a href="http://www.hollischuang.com/archives/99#getBytes" target="_blank" rel="noopener">getBytes</a></p>
<p><a href="http://www.hollischuang.com/archives/99#%E6%AF%94%E8%BE%83%E6%96%B9%E6%B3%95" target="_blank" rel="noopener">比较方法</a></p>
<p><a href="http://www.hollischuang.com/archives/99#hashCode" target="_blank" rel="noopener">hashCode</a></p>
<p><a href="http://www.hollischuang.com/archives/99#substring" target="_blank" rel="noopener">substring</a></p>
<p><a href="http://www.hollischuang.com/archives/99#replaceFirst%E3%80%81replaceAll%E3%80%81replace%E5%8C%BA%E5%88%AB" target="_blank" rel="noopener">replaceFirst、replaceAll、replace区别</a></p>
<p><a href="http://www.hollischuang.com/archives/99#copyValueOf%E5%92%8CvalueOf" target="_blank" rel="noopener">copyValueOf 和 valueOf</a></p>
<p><a href="http://www.hollischuang.com/archives/99#intern" target="_blank" rel="noopener">intern</a></p>
<p><a href="http://www.hollischuang.com/archives/99#String%E5%AF%B9%E2%80%9C+%E2%80%9D%E7%9A%84%E9%87%8D%E8%BD%BD" target="_blank" rel="noopener">String对“+”的重载</a></p>
<p><a href="http://www.hollischuang.com/archives/99#String.valueOf%E5%92%8CInteger.toString%E7%9A%84%E5%8C%BA%E5%88%AB" target="_blank" rel="noopener">String.valueOf和Integer.toString的区别</a></p>
</blockquote>
<p><a href="http://www.hollischuang.com/archives/99#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99" target="_blank" rel="noopener">参考资料</a></p>
</blockquote>
<hr>
<h2 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>从该类的声明中我们可以看出String是final类型的，表示该类不能被继承，同时该类实现了三个接口：<code>java.io.Serializable</code>、 <code>Comparable&lt;String&gt;</code>、 <code>CharSequence</code></p>
<hr>
<h2 id="二、属性"><a href="#二、属性" class="headerlink" title="二、属性"></a>二、属性</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private final char value[];</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这是一个字符数组，并且是final类型，他用于存储字符串内容，从fianl这个关键字中我们可以看出，String的内容一旦被初始化了是不能被更改的。 虽然有这样的例子： String s = “a”; s = “b” 但是，这并不是对s的修改，而是重新指向了新的字符串， 从这里我们也能知道，<strong>String其实就是用char[]实现的。</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private int hash;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>缓存字符串的<a href="http://www.hollischuang.com/archives/99#hashCode" target="_blank" rel="noopener">hash Code</a>，默认值为 0</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private static final long serialVersionUID = -6849794470754667710L;</span><br><span class="line">private static final ObjectStreamField[] serialPersistentFields = new ObjectStreamField[0];</span><br></pre></td></tr></table></figure>
<blockquote>
<p>因为<code>String</code>实现了<code>Serializable</code>接口，所以支持序列化和反序列化支持。Java的序列化机制是通过在运行时判断类的<code>serialVersionUID</code>来验证版本一致性的。在进行反序列化时，JVM会把传来的字节流中的<code>serialVersionUID</code>与本地相应实体（类）的<code>serialVersionUID</code>进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常(<code>InvalidCastException</code>)。</p>
</blockquote>
<hr>
<h2 id="三、构造方法"><a href="#三、构造方法" class="headerlink" title="三、构造方法"></a>三、构造方法</h2><p>String类作为一个java.lang包中比较常用的类,自然有很多重载的构造方法.在这里介绍几种典型的构造方法:</p>
<h3 id="1-使用字符数组、字符串构造一个String"><a href="#1-使用字符数组、字符串构造一个String" class="headerlink" title="1.使用字符数组、字符串构造一个String"></a><strong>1.使用字符数组、字符串构造一个String</strong></h3><p>我们知道，其实String就是使用字符数组（char[]）实现的。所以我们可以使用一个字符数组来创建一个String，那么这里值得注意的是，<strong>当我们使用字符数组创建String的时候，会用到Arrays.copyOf方法和Arrays.copyOfRange方法。这两个方法是将原有的字符数组中的内容逐一的复制到String中的字符数组中。</strong>同样，我们也可以用一个String类型的对象来初始化一个String。这里将直接将<code>源String</code>中的<code>value</code>和<code>hash</code>两个属性直接赋值给<code>目标String</code>。因为String一旦定义之后是不可以改变的，所以也就不用担心改变<code>源String</code>的值会影响到<code>目标String</code>的值。</p>
<blockquote>
<p>当然，在使用字符数组来创建一个新的String对象的时候，不仅可以使用整个字符数组，也可以使用字符数组的一部分，只要多传入两个参数<code>int offset</code>和<code>int count</code>就可以了。</p>
</blockquote>
<hr>
<h3 id="2-使用字节数组构造一个String"><a href="#2-使用字节数组构造一个String" class="headerlink" title="2.使用字节数组构造一个String"></a><strong>2.使用字节数组构造一个String</strong></h3><p>在Java中，String实例中保存有一个<code>char[]</code>字符数组，<code>char[]</code>字符数组是以unicode码来存储的，String 和 char 为内存形式，byte是网络传输或存储的序列化形式。所以在很多传输和存储的过程中需要将byte[]数组和String进行相互转化。所以，String提供了一系列重载的构造方法来将一个字符数组转化成String，提到byte[]和String之间的相互转换就不得不关注编码问题。<strong>String(byte[] bytes, Charset charset)是指通过charset来解码指定的byte数组，将其解码成unicode的char[]数组，够造成新的String。</strong></p>
<blockquote>
<p><strong>这里的bytes字节流是使用charset进行编码的，想要将他转换成unicode的char[]数组，而又保证不出现乱码，那就要指定其解码方式</strong></p>
</blockquote>
<p>同样使用字节数组来构造String也有很多种形式，按照是否指定解码方式分的话可以分为两种：</p>
<blockquote>
<p>String(byte bytes[]) String(byte bytes[], int offset, int length)</p>
<p>String(byte bytes[], Charset charset)</p>
<p>String(byte bytes[], String charsetName)</p>
<p>String(byte bytes[], int offset, int length, Charset charset)</p>
<p>String(byte bytes[], int offset, int length, String charsetName)</p>
</blockquote>
<p>如果我们在使用byte[]构造String的时候，使用的是下面这四种构造方法(带有<code>charsetName</code>或者<code>charset</code>参数)的一种的话，那么就会使用<code>StringCoding.decode</code>方法进行解码，使用的解码的字符集就是我们指定的<code>charsetName</code>或者<code>charset</code>。 我们在使用byte[]构造String的时候，如果没有指明解码使用的字符集的话，那么<code>StringCoding</code>的<code>decode</code>方法首先调用系统的默认编码格式，如果没有指定编码格式则默认使用<strong>ISO-8859-1</strong>编码格式进行编码操作。主要体现代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">static char[] decode(byte[] ba, int off, int len) &#123;</span><br><span class="line">      String csn = Charset.defaultCharset().name();</span><br><span class="line">      try &#123;</span><br><span class="line">          // use charset name decode() variant which provides caching.</span><br><span class="line">          return decode(csn, ba, off, len);</span><br><span class="line">      &#125; catch (UnsupportedEncodingException x) &#123;</span><br><span class="line">          warnUnsupportedCharset(csn);</span><br><span class="line">      &#125;</span><br><span class="line">      try &#123;</span><br><span class="line">          return decode(&quot;ISO-8859-1&quot;, ba, off, len);</span><br><span class="line">      &#125; catch (UnsupportedEncodingException x) &#123;</span><br><span class="line">          // If this code is hit during VM initialization, MessageUtils is</span><br><span class="line">          // the only way we will be able to get any kind of error message.</span><br><span class="line">          MessageUtils.err(&quot;ISO-8859-1 charset not available: &quot;</span><br><span class="line">                           + x.toString());</span><br><span class="line">          // If we can not find ISO-8859-1 (a required encoding) then things</span><br><span class="line">          // are seriously wrong with the installation.</span><br><span class="line">          System.exit(1);</span><br><span class="line">          return null;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="3-使用StringBuffer和StringBuider构造一个String"><a href="#3-使用StringBuffer和StringBuider构造一个String" class="headerlink" title="3.使用StringBuffer和StringBuider构造一个String"></a><strong>3.使用StringBuffer和StringBuider构造一个String</strong></h3><p>作为String的两个“兄弟”，StringBuffer和StringBuider也可以被当做构造String的参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public String(StringBuffer buffer) &#123;</span><br><span class="line">    synchronized(buffer) &#123;</span><br><span class="line">        this.value = Arrays.copyOf(buffer.getValue(), buffer.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String(StringBuilder builder) &#123;</span><br><span class="line">    this.value = Arrays.copyOf(builder.getValue(), builder.length());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，这两个构造方法是很少用到的，至少我从来没有使用过，因为当我们有了StringBuffer或者StringBuilfer对象之后可以直接使用他们的toString方法来得到String。关于效率问题，Java的官方文档有提到说使用StringBuilder的toString方法会更快一些，原因是StringBuffer的<code>toString</code>方法是synchronized的，在牺牲了效率的情况下保证了线程安全。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> public String toString() &#123;</span><br><span class="line">    // Create a copy, don&apos;t share the array</span><br><span class="line">    return new String(value, 0, count);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">this.value = Arrays.copyOfRange(value, offset, offset+count);</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="4-一个特殊的保护类型的构造方法"><a href="#4-一个特殊的保护类型的构造方法" class="headerlink" title="4.一个特殊的保护类型的构造方法"></a><strong>4.一个特殊的保护类型的构造方法</strong></h3><p>String除了提供了很多公有的供程序员使用的构造方法以外，还提供了一个保护类型的构造方法（Java 7），我们看一下他是怎么样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String(char[] value, boolean share) &#123;</span><br><span class="line">    // assert share : &quot;unshared not supported&quot;;</span><br><span class="line">    this.value = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码中我们可以看出，该方法和 <code>String(char[] value)</code>有两点区别，第一个，该方法多了一个参数： <code>boolean share</code>，其实这个参数在方法体中根本没被使用，也给了注释，目前不支持使用false，只使用true。那么可以断定，<strong>加入这个share的只是为了区分于String(char[] value)方法</strong>，不加这个参数就没办法定义这个函数，只有参数不能才能进行重载。那么，第二个区别就是具体的方法实现不同。我们前面提到过，<code>String(char[] value)</code>方法在创建String的时候会用到 会用到<code>Arrays</code>的<code>copyOf</code>方法将value中的内容逐一复制到String当中，而这个<code>String(char[] value, boolean share)</code>方法则是直接将value的引用赋值给String的value。那么也就是说，这个方法构造出来的String和参数传过来的<code>char[] value</code>共享同一个数组。 那么，为什么Java会提供这样一个方法呢？ 首先，我们分析一下使用该构造函数的好处：</p>
<blockquote>
<p>首先，<strong>性能好</strong>，这个很简单，一个是直接给数组赋值（相当于直接将String的value的指针指向char[]数组），一个是逐一拷贝。当然是直接赋值快了。</p>
<p>其次，共享内部数组<strong>节约内存</strong></p>
</blockquote>
<p>但是，该方法之所以设置为protected，是因为一旦该方法设置为公有，在外面可以访问的话，那就破坏了字符串的不可变性。例如如下YY情形：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">char[] arr = new char[] &#123;&apos;h&apos;, &apos;e&apos;, &apos;l&apos;, &apos;l&apos;, &apos;o&apos;, &apos; &apos;, &apos;w&apos;, &apos;o&apos;, &apos;r&apos;, &apos;l&apos;, &apos;d&apos;&#125;;</span><br><span class="line">String s = new String(0, arr.length, arr); // &quot;hello world&quot;</span><br><span class="line">arr[0] = &apos;a&apos;; // replace the first character with &apos;a&apos;</span><br><span class="line">System.out.println(s); // aello world</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/02/16/Java基础之String源码/" data-id="ck05zzdaw000h4sumvjg6rnp2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java基础/">Java基础</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/05/05/《编写可读代码的艺术》读书笔记——代码审美/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          《编写可读代码的艺术》读书笔记——代码审美
        
      </div>
    </a>
  
  
    <a href="/2019/02/05/《编写可读代码的艺术》读书笔记——注释/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">《编写可读代码的艺术》读书笔记——注释</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java基础/">Java基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/">Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring/">spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/素养/">素养</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/读书笔记/">读书笔记</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Java基础/" style="font-size: 20px;">Java基础</a> <a href="/tags/Spring/" style="font-size: 10px;">Spring</a> <a href="/tags/spring/" style="font-size: 20px;">spring</a> <a href="/tags/素养/" style="font-size: 10px;">素养</a> <a href="/tags/读书笔记/" style="font-size: 15px;">读书笔记</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/09/05/Java反射与动态代理/">Java反射与动态代理</a>
          </li>
        
          <li>
            <a href="/2019/05/05/《编写可读代码的艺术》读书笔记——代码审美/">《编写可读代码的艺术》读书笔记——代码审美</a>
          </li>
        
          <li>
            <a href="/2019/02/16/Java基础之String源码/">Java基础之String源码</a>
          </li>
        
          <li>
            <a href="/2019/02/05/《编写可读代码的艺术》读书笔记——注释/">《编写可读代码的艺术》读书笔记——注释</a>
          </li>
        
          <li>
            <a href="/2019/01/26/程序员的职业素养/">程序员的职业素养</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>